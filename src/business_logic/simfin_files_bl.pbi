;╔═════════════════════════════════════════════════════════════════════════════════════════════════
;║     simfin_files_bl.pbi                                                                           
;╠═════════════════════════════════════════════════════════════════════════════════════════════════
;║     Created: 16-08-2025 
;║
;║     Copyright (c) 2025 James Dooley <james@dooley.ch>
;║
;║     History:
;║     16-08-2025: Initial version
;╚═════════════════════════════════════════════════════════════════════════════════════════════════

DeclareModule SimFinFilesBL
  
  Prototype LogErrorMessage(message$) ; Used during downloading SimFin files to log errors 
  Prototype LogInfoMessage(message$)  ; Used during downloading to record successful downloads
  
  ; Holds the credentials needed to make an API call to the SimFin website
  Structure SimFinAccountRecord
    Url.s       ; The website address
    Key.s       ; The SimFin API key
    MaxCalls.i  ; The maximum number of API calls allowed per day
  EndStructure
  
  ; Holds the parameters needed to initialise the module before it can be used
  ;
  Structure ModuleInitRecord
    ConfigFileName.s
    DownloadsFolder.s
    UnpackFolder.s
    SimFinAccount.SimFinAccountRecord
    LogErrorProc.LogErrorMessage
    LogInfoProc.LogInfoMessage
  EndStructure
  
  ; Holds the control information about each required
  ; SimFin file
  Structure SimFinFileRecord
    DataSet.s
    Market.s
    Variant.s
    ZipFileName.s
    CsvFileName.s
    ZipFileSize.i
    CsvFileSize.i
    Downloaded.b
    Unzipped.b
    httpStatusCode.i
    ErrorMessage.s
  EndStructure
  
  Declare.b Init(*record.ModuleInitRecord)    ; Initializes the module  
  
  Declare.b GetSimFinDownloadMetaData(List items.SimFinFileRecord())  ; Returns a list of all the required SimFin files and their status
  Declare.b DownloadSimFile(*record.SimFinFileRecord)                         ; Download file from SimFin website
  
  Declare.s LastError() ; Returns last error generated by the module

EndDeclareModule

Module SimFinFilesBL
  EnableExplicit
  UseZipPacker()
  
  #EmptyDefinition = "[]"
  
  ; Holds the details of file stored on disk
  ;
  Structure FileInfoRecord
    Name.s
    FileSize.i
  EndStructure
  
  ; Holds the details of the credentials needed to
  ; connect to the SimFin website
  ;
  Structure SimFinCredentialsRecord
    URL.s
    Key.s
    MaxCalls.i
  EndStructure
  
  ;┌───────────────────────────────────────────────────────────────────────────────────────────────
  ;│     Module variables & support routines     
  ;└───────────────────────────────────────────────────────────────────────────────────────────────  
  
  ; ───────────────────────────────────────────────────────────────────────────────────────────────
  ; Module error message management
  Define lastErrorMessage$ = #Empty$
  
  ; Sets the module error message variable to an empty string
  Procedure ResetLastErrorMEssage()
    Shared lastErrorMessage$
    
    lastErrorMessage$ = #Empty$
  EndProcedure
  
  ; ───────────────────────────────────────────────────────────────────────────────────────────────  
  ; Initialisation variables
  Define isInitialised.b = #False,
         maxApiCalls.i = 0,
         initParams.ModuleInitRecord

  Macro IsModuleInitialised()
    Shared isInitialised, lastErrorMessage$
    
    lastErrorMessage$ = #Empty$
    
    If Not isInitialised
      lastErrorMessage$ = "The SimFinFilesBL has not been initialized.  Call SimFinFilesBL::Init() before using module"
      ProcedureReturn #False
    EndIf
  EndMacro
  
  
  ; ───────────────────────────────────────────────────────────────────────────────────────────────
  ; File handling routines
  
  ; Adds two path elements togeather ensuring the correct separator is used
  Procedure.s MakePath(basePart$, value$) 
    CompilerIf (#PB_Compiler_OS = #PB_OS_Windows) 
      #PATH_SEPARATOR = "\"
    CompilerElse
      #PATH_SEPARATOR = "/"
    CompilerEndIf    
    
    If (Bool(Len(#PATH_SEPARATOR) And (LCase(Right(basePart$, Len(#PATH_SEPARATOR))) = LCase(#PATH_SEPARATOR))))
      ProcedureReturn basePart$ + value$
    EndIf
    
    ProcedureReturn basePart$ + #PATH_SEPARATOR + value$
  EndProcedure
  
  ; ───────────────────────────────────────────────────────────────────────────────────────────────
  ; Support routines
  
  Procedure.b SplitValueList(values$, List items$())
    Protected value$ = #Empty$, index.i = -1
    
    ClearList(items$())
    
    If values$ = #EmptyDefinition
      ProcedureReturn #False
    EndIf
    
    values$ = Trim(RemoveString(values$, "["))
    values$ = Trim(RemoveString(values$, "]"))
    
    While values$ <> #Empty$ 
      index = FindString(values$, ",", #PB_String_CaseSensitive)

      If index > 0
        value$ = Left(values$, index - 1)
        values$ = Trim(Mid(values$, index + 1))
      Else
        value$ = values$
        values$ = #Empty$
      EndIf
      
      AddElement(items$())
      items$() = value$
    Wend
    
    ResetList(items$())
    ProcedureReturn #True
  EndProcedure
  
  Procedure.b GetFileDetails(folderName$, List items.FileInfoRecord(), ext$ = "*.zip")
    Protected hFolder.i, fileName$, size.i
    Protected *record.FileInfoRecord 
    
    ClearList(items())
    
    hFolder = ExamineDirectory(#PB_Any, folderName$, ext$)
    If IsDirectory(hFolder)
      While NextDirectoryEntry(hFolder)
        If DirectoryEntryType(hFolder) = #PB_DirectoryEntry_File
          fileName$ = DirectoryEntryName(hFolder)
          size = DirectoryEntrySize(hFolder)
          
          *record = AddElement(items())
          *record\Name = fileName$
          *record\FileSize = size
        EndIf
      Wend
    EndIf
    
    ResetList(items())
    
    ProcedureReturn #True
  EndProcedure
  
  Procedure.b InitSimFinFileRecord(*record.SimFinFileRecord) 
    With *record
      \DataSet = #Empty$
      \Market = "null"
      \Variant = "null"
      \ZipFileName = #Empty$
      \CsvFileName = #Empty$
      \ZipFileSize = 0
      \CsvFileSize = 0
      \Downloaded = #False
      \Unzipped = #False
      \httpStatusCode = 0
      \ErrorMessage = #Empty$
    EndWith
    
    ProcedureReturn #True
  EndProcedure
  
  Procedure.b SaveDownloadedFile(hResponse.i, fileName$)
    Protected *data, dataSize.i, hFile.i
    
    *data = HTTPMemory(hResponse)
    dataSize = MemorySize(*data)
    
    hFile = CreateFile(#PB_Any, fileName$, #PB_File_NoBuffering)
    If IsFile(hFile)
      WriteData(hFile, *data, dataSize)
      CloseFile(hFile)
      ProcedureReturn #True
    EndIf
  
    ProcedureReturn #False
  EndProcedure
  
  Procedure.b UnzipDownloadedFile(sourceFile$, targetFile$)
    ResetLastErrorMEssage()
    
    Shared lastErrorMessage$
    Protected hPackage.i, sourceFileName$, targetFileName$, csvFileName$, returnFlag.b = #True
    
    sourceFileName$ = GetFilePart(sourceFile$)
    targetFileName$ = GetFilePart(targetFile$)
    
    hPackage = OpenPack(#PB_Any, sourceFile$, #PB_PackerPlugin_Zip)
    If hPackage
      If ExaminePack(hPackage)
        If NextPackEntry(hPackage)
          csvFileName$ = PackEntryName(hPackage)
          
          If csvFileName$ = targetFileName$
            If UncompressPackFile(hPackage, targetFile$, csvFileName$) = -1
              lastErrorMessage$ = "The to decompress zip file (" + sourceFileName$ + ")"
              returnFlag = #False
            EndIf
          Else
            lastErrorMessage$ = "The zip file (" + sourceFileName$ + ") does Not contain the expected csv file: " + targetFileName$
            returnFlag = #False
          EndIf
        Else
          lastErrorMessage$ = "Unable to obtain package entry: " + sourceFileName$
          returnFlag = #False       
        EndIf
      Else
        lastErrorMessage$ = "Unable to examine zip file: " + sourceFileName$
        returnFlag = #False            
      EndIf
      
      ClosePack(hPackage)
    Else
      lastErrorMessage$ = "Failed to unzip file: " + sourceFileName$
      returnFlag = #False
    EndIf
    
    ProcedureReturn returnFlag
  EndProcedure
  
  ;┌───────────────────────────────────────────────────────────────────────────────────────────────
  ;│     Public     
  ;└───────────────────────────────────────────────────────────────────────────────────────────────

  ; Returns last error generated by the module
  ;
  Procedure.s LastError()
    Shared lastErrorMessage$
  
    ProcedureReturn lastErrorMessage$
  EndProcedure
    
  ; Returns a list of all the required SimFin files and their status
  ;
  ; Params
  ;   items - Liast to populate
  ;
  ; Returns
  ;   Returns true if successful otherwise false
  ;
  Procedure.b GetSimFinDownloadMetaData(List items.SimFinFileRecord()) 
    ResetLastErrorMEssage()
    IsModuleInitialised()
    
    Shared initParams
    
    Protected *entry.SimFinFileRecord
    Protected dataSet$, market$, variant$, marketNames$, variantNames$
    Protected NewList listOfMarkets$(), NewList listOfVariants$(), NewList files.FileInfoRecord()
    
    ClearList(items())
    
    ; Populate list
    If OpenPreferences(initParams\ConfigFileName, #PB_Preference_GroupSeparator, #PB_UTF8)
      ExaminePreferenceGroups()
      
      While NextPreferenceGroup()
        dataSet$ = PreferenceGroupName()
        
        PreferenceGroup(dataSet$)
        marketNames$ = ReadPreferenceString("market", "[]")
        variantNames$ = ReadPreferenceString("variant", "[]")
        
        If (marketNames$ = #EmptyDefinition) And (variantNames$ = #EmptyDefinition)
          *entry = AddElement(items())
          InitSimFinFileRecord(*entry)
          
          With *entry
            \DataSet = dataSet$
            \ZipFileName = dataSet$ + ".zip"
            \CsvFileName = dataSet$ + ".csv"
          EndWith
          
          Continue
        EndIf
        
        If (marketNames$ <> #EmptyDefinition) And (variantNames$ = #EmptyDefinition)
          ClearList(listOfMarkets$())
          If SplitValueList(marketNames$, listOfMarkets$())
            ForEach listOfMarkets$()
              market$ = listOfMarkets$()
              
              *entry = AddElement(items())
              InitSimFinFileRecord(*entry)
          
              With *entry
                \DataSet = dataSet$
                \Market = market$
                \ZipFileName = market$ + "-" + dataSet$ + ".zip"
                \CsvFileName = market$ + "-" + dataSet$ + ".csv"
              EndWith
            Next
          EndIf
          
          Continue
        EndIf
        
        If (marketNames$ = #EmptyDefinition) And (variantNames$ <> #EmptyDefinition)
          ClearList(listOfVariants$())
          If SplitValueList(variantNames$, listOfVariants$())
            ForEach listOfVariants$()
              variant$ = listOfVariants$()
              
              *entry = AddElement(items())
              InitSimFinFileRecord(*entry)
              
              With *entry
                \DataSet = dataSet$
                \Variant = variant$
                \ZipFileName = dataSet$ + "-" + variant$ + ".zip"
                \CsvFileName = dataSet$ + "-" + variant$ + ".csv"
              EndWith
            Next
          EndIf
          
          Continue
        EndIf
        
        ; Create full set of files
        ClearList(listOfMarkets$())
        ClearList(listOfVariants$())
        
        If SplitValueList(marketNames$, listOfMarkets$()) And 
           SplitValueList(variantNames$, listOfVariants$())
          
          ForEach listOfVariants$()
            variant$ = listOfVariants$()
            
            ForEach listOfMarkets$()
              market$ = listOfMarkets$()
              
              *entry = AddElement(items())
              InitSimFinFileRecord(*entry)
              
              With *entry
                \DataSet = dataSet$
                \Market = market$
                \Variant = variant$
                \ZipFileName = market$ + "-" + dataSet$ + "-" + variant$ + ".zip"
                \CsvFileName = market$ + "-" + dataSet$ + "-" + variant$ + ".csv"
              EndWith              
            Next
          Next
        EndIf  
      Wend
      
      ClosePreferences()
      
      ; Add the download information
      ClearList(files())
      If GetFileDetails(initParams\DownloadsFolder, files(), "*.zip")
        ForEach files()
          ResetList(items())
          
          ForEach items()
            If files()\Name = items()\ZipFileName
              items()\ZipFileSize = files()\FileSize
              items()\Downloaded = #True
              Break  
            EndIf
          Next
        Next
      EndIf
      
      ; Add the unzipped information
      ClearList(files())
      If GetFileDetails(initParams\UnpackFolder, files(), "*.csv")
        ForEach files()
          ResetList(items())
          
          ForEach items()
            If files()\Name = items()\CsvFileName
              items()\CsvFileSize = files()\FileSize
              items()\Unzipped = #True
              Break  
            EndIf
          Next
        Next
      EndIf
      
      ResetList(items())
      ProcedureReturn #True
    EndIf
    
    lastErrorMessage$ = "Failed to open simfin-files.ini file"
    ProcedureReturn #False
  EndProcedure
   
  ; Download file from SimFin website
  ;
  ; Params
  ; *record - details of the file to be downloaded
  ;
  ; Return
  ;   True if successful, otherwise false
  ;
  Procedure.b DownloadSimFile(*record.SimFinFileRecord) 
    ResetLastErrorMEssage()
    IsModuleInitialised()
    
    Shared initParams
    
    Protected url$, NewMap headers$(), hResponse.i, statusCode.i, returnFlag.b = #True
    
    ; Setup the call
    url$ = initParams\SimFinAccount\Url
    url$ = SetURLPart(url$, "dataset", *record\DataSet)
    url$ = SetURLPart(url$, "variant", *record\Variant)
    url$ = SetURLPart(url$, "market", *record\Market)
    
    Headers$("Authorization") = "api-key " + initParams\SimFinAccount\Key
    
    ; Make the call
    hResponse = HTTPRequestMemory(#PB_HTTP_Get, url$, #PB_Ignore, 0, #PB_HTTP_NoSSLCheck, headers$())
    
    ; Process the response
    If hResponse
      statusCode = Val(HTTPInfo(hResponse, #PB_HTTP_StatusCode))
      *record\httpStatusCode = statusCode
      
      If statusCode > 0        
        Select statusCode
          Case 200
            If SaveDownloadedFile(hResponse, MakePath(initParams\DownloadsFolder, *record\ZipFileName))
              *record\Downloaded = #True
              
              If UnzipDownloadedFile(MakePath(initParams\DownloadsFolder, *record\ZipFileName),
                                     MakePath(initParams\UnpackFolder, *record\CsvFileName))
                *record\Unzipped = #True
                initParams\LogInfoProc("File downloaded: " + *record\ZipFileName)
              Else
                initParams\LogErrorProc(lastErrorMessage$)
                lastErrorMessage$ = "Failed to unzip file: " + *record\ZipFileName
                *record\ErrorMessage = lastErrorMessage$
                initParams\LogErrorProc(lastErrorMessage$)
                returnFlag = #False                   
              EndIf
            Else
              lastErrorMessage$ = "Failed to save downloaded file: " + *record\ZipFileName
              *record\ErrorMessage = lastErrorMessage$
              initParams\LogErrorProc(lastErrorMessage$)
              returnFlag = #False                 
            EndIf
          Case 400
            lastErrorMessage$ = Str(statusCode) + " - " + HTTPInfo(hResponse, #PB_HTTP_Response)
            *record\ErrorMessage = lastErrorMessage$
            initParams\LogErrorProc(lastErrorMessage$)
            returnFlag = #False   
          Case 401
            lastErrorMessage$ = Str(statusCode) + " - " + "Unauthorized request to a protected API" 
            *record\ErrorMessage = lastErrorMessage$
            initParams\LogErrorProc(lastErrorMessage$)
            returnFlag = #False   
          Case 429
            lastErrorMessage$ = Str(statusCode) + " - " + "You have exhausted your API request quota for the day"
            *record\ErrorMessage = lastErrorMessage$
            initParams\LogErrorProc(lastErrorMessage$)
            returnFlag = #False                
          Case 500
            lastErrorMessage$ = Str(statusCode) + " - " + HTTPInfo(hResponse, #PB_HTTP_Response)
            *record\ErrorMessage = lastErrorMessage$
            initParams\LogErrorProc(lastErrorMessage$)
            returnFlag = #False 
          Default
            lastErrorMessage$ = Str(statusCode) + " - " + "Failed to download file: " + *record\ZipFileName
            *record\ErrorMessage = lastErrorMessage$
            initParams\LogErrorProc(lastErrorMessage$)
            returnFlag = #False
        EndSelect
        
        FinishHTTP(hResponse)
        ProcedureReturn returnFlag
      EndIf
      
      lastErrorMessage$ = Str(statusCode) + " - " + HTTPInfo(hResponse, #PB_HTTP_ErrorMessage)
      ProcedureReturn #False
    EndIf
    
    lastErrorMessage$ = "Failed to make HTTP call to download: " + *record\ZipFileName
    ProcedureReturn #False
  EndProcedure
  
  ; Initializes the module
  ;
  ; Params
  ;   *record - Holds the module initialisation parameters
  ;
  ; Returns
  ;   Always returns True
  ;
  Procedure.b Init(*record.ModuleInitRecord)   
    Shared isInitialised, initParams
    
    CopyStructure(*record, @initParams, ModuleInitRecord)
    isInitialised = #True
  EndProcedure
  
EndModule

;┌───────────────────────────────────────────────────────────────────────────────────────────────
;│     Example     
;└───────────────────────────────────────────────────────────────────────────────────────────────
CompilerIf (#PB_Compiler_IsMainFile)
  DisableExplicit
  
  ; Initialise the module
  
  Define initParams.SimFinFilesBL::ModuleInitRecord
  
  Procedure LogInfoProc(message$) ; Callback for logging info messages
    Debug "Info: " + message$
  EndProcedure
  
  Procedure LogErrorProc(message$) ; Callback for logging error messages
    Debug "Error: " + message$
  EndProcedure
  
  ; CONFIG : Change the folder names and values to suit the environment
  With initParams
    \ConfigFileName = "/Users/jdooley/dooley.ch/financial-statements-loader/simfin-files.ini"
    \DownloadsFolder = "/Users/jdooley/dooley.ch/financial-statements-loader/Data/downloads"
    \UnpackFolder = "/Users/jdooley/dooley.ch/financial-statements-loader/Data/csv"
    \SimFinAccount\Url = "http://localhost:8080/api/bulk-download/s3"
    \SimFinAccount\Key = "1234567890"
    \SimFinAccount\MaxCalls = 60
    \LogErrorProc = @LogErrorProc()
    \LogInfoProc = @LogInfoProc()
  EndWith
  
  SimFinFilesBL::Init(@initParams)
  
  ; Obtain the list of files to download
  
  NewList items.SimFinFilesBL::SimFinFileRecord()
  
  If Not SimFinFilesBL::GetSimFinDownloadMetaData(items())
    Debug SimFinFilesBL::LastError()
    End
  EndIf
  
  *record.SimFinFilesBL::SimFinFileRecord = FirstElement(items())
  
  While *record
    If Not SimFinFilesBL::DownloadSimFile(*record)
      Select *record\httpStatusCode
        Case 0
          Debug "Unable to establish a connection - " + SimFinFilesBL::LastError()
          End
        Case 400
          Debug "Invalid request while attempting to download file (" + *record\ZipFileName + "): " + SimFinFilesBL::LastError()
          End
        Case 401
          Debug "Invalid website credentials supplied"
          End
        Case 429
          Debug "API Limit exceeded"
          End                          
        Default
          Debug "Unhandled error: " + SimFinFilesBL::LastError()
          End
      EndSelect
    EndIf
    
    *record = NextElement(items())
  Wend

CompilerEndIf

; IDE Options = PureBasic 6.21 - C Backend (MacOS X - arm64)
; ExecutableFormat = Console
; CursorPosition = 586
; FirstLine = 579
; Folding = ----
; EnableXP
; DPIAware